# This is the main artifact of the thesis (Chapter 5)
# It implements the 4-stage framework: Build, Analyze, Enforce, Attest

name: DevSecOps Secure Supply Chain

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    name: 1 - Build and Analyze
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify Go Module Files
        run: |
          if [[ ! -f app/go.mod || ! -f app/go.sum ]]; then
            echo "Error: app/go.mod or app/go.sum missing. Please commit these files."
            exit 1
          else
            echo "app/go.mod and app/go.sum found."
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=,format=short

      - name: Build Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./app
          file: ./app/Dockerfile
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Generate SBOM (Syft)
        uses: anchore/sbom-action@v0
        with:
          image: ${{ steps.meta.outputs.tags }}
          format: cyclonedx-json
          output-file: bom.json

      - name: Scan for Vulnerabilities (Grype)
        uses: anchore/scan-action@v6
        with:
          sbom: bom.json
          output-file: vulnerabilities.json
          output-format: json
          fail-build: false

      - name: Save Docker image to tarball
        run: docker save ${{ steps.meta.outputs.tags }} -o /tmp/docker-image.tar

      - name: Upload Artifacts (SBOM & Scan)
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: |
            bom.json
            vulnerabilities.json
          retention-days: 7

      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image.tar
          retention-days: 7

  policy-gate:
    name: 2 - Enforce Security Policy
    runs-on: ubuntu-latest
    needs: [build] # This job runs only after 'build' succeeds

    # --- ADD THIS OUTPUTS BLOCK ---
    # We pass the image tag through this job so the next job can access it
    outputs:
      image_tag: ${{ needs.build.outputs.image_tag }}
    # --- END OF ADDITION ---

    steps:
      - name: Checkout repository (for OPA policy file)
        uses: actions/checkout@v4

      - name: Download security reports
        uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: .

      - name: Install Open Policy Agent (OPA)
        run: |
          # THE FIX IS HERE: Use the "latest" release URL
          curl -L -o opa https://github.com/open-policy-agent/opa/releases/latest/download/opa_linux_amd64
          chmod +x ./opa

      # --- NEW DEBUG STEP ---
      # This step will show us what was *actually* downloaded.
      - name: Verify OPA Download
        run: |
          echo "Verifying the downloaded 'opa' file:"
          file ./opa
          echo "--- First line of ./opa file: ---"
          head -n 1 ./opa
          echo "---------------------------------"
      # --- END NEW DEBUG STEP ---

      - name: Create OPA Input JSON
        run: |
          jq -n --slurpfile grype vulnerabilities.json --slurpfile syft bom.json \
            '{"vulnerabilities": $grype[0], "sbom": $syft[0]}' > input.json
          echo "Generated input.json for OPA:"
          cat input.json | jq .

      - name: Run OPA Policy Gate
        run: |
          ./opa eval --fail \
            --input input.json \
            --data policy/policy.rego \
            "data.main.allow"
          echo "OPA Policy PASSED"

  sign-and-publish:
    name: 3 - Attest and Publish
    runs-on: ubuntu-latest
    needs: [policy-gate] # Only runs if the policy gate PASSED
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Download Docker Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load -i /tmp/docker-image.tar

      - name: Get Image Tag
        id: image_tag
        # --- MODIFY THIS LINE ---
        # Read the output from 'policy-gate' instead of 'build'
        run: echo "tag=${{ needs.policy-gate.outputs.image_tag }}" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Sigstore/cosign
        uses: sigstore/cosign-installer@v3

      # --- STEP 1 (MOVED): Push the unsigned image first ---
      - name: Push image to registry
        run: |
          docker push ${{ steps.image_tag.outputs.tag }}

      # --- STEP 2: Sign the image (now that it's in the registry) ---
      - name: Sign the image with Sigstore
        run: |
          cosign sign \
            --yes \
            ${{ steps.image_tag.outputs.tag }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Download SBOM report
        uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: .

      - name: Attach SBOM Attestation
        run: |
          cosign attest \
            --yes \
            --type cyclonedx \
            --predicate bom.json \
            ${{ steps.image_tag.outputs.tag }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Verify Image Signature
        run: |
          cosign verify \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            --certificate-identity-regexp "^https://github.com/${{ github.repository }}/.*" \
            ${{ steps.image_tag.outputs.tag }}
        env:
          COSIGN_EXPERIMENTAL: 1

      # --- This step is no longer needed, as we pushed first ---
      # - name: Push signed image to registry
      #   run: |
      #     docker push ${{ steps.image_tag.outputs.tag }}