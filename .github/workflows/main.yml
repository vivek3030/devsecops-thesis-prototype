# This is the main artifact of the thesis (Chapter 5)
# It implements the 4-stage framework: Build, Analyze, Enforce, Attest
# This v6 version is refactored based on expert review to be robust and reproducible.

name: DevSecOps Secure Supply Chain

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  # Use github.repository (e.g., vivek3030/devsecops-thesis-prototype) as the base image name
  IMAGE_NAME: ${{ github.repository }}

jobs:
  #========================================
  # JOB 1: BUILD & ANALYZE
  #========================================
  build:
    name: 1 - Build and Analyze
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      image_tag: ${{ steps.vars.outputs.image }} # Pass the canonical tag to downstream jobs

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # --- FIX #1: Canonical Image Tag ---
      # Set a single, deterministic image tag based on the commit SHA
      # This fixes the ambiguity of using docker/metadata-action
      - name: Set canonical image tag
        id: vars
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "image=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # --- STAGE 1: BUILD ---
      - name: Build Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./app # Correct build context
          file: ./app/Dockerfile
          push: false # Do not push yet
          load: true  # Load into local daemon
          tags: ${{ steps.vars.outputs.image }} # Use the canonical tag

      # --- STAGE 2: ANALYZE (SBOM) ---
      - name: Generate SBOM (Syft)
        uses: anchore/sbom-action@v0
        with:
          image: ${{ steps.vars.outputs.image }}
          format: cyclonedx-json # Use the correct JSON format
          output-file: bom.json

      # --- STAGE 2: ANALYZE (Scan) ---
      - name: Scan for Vulnerabilities (Grype)
        uses: anchore/scan-action@v6
        with:
          sbom: bom.json # Scan the SBOM
          output-file: vulnerabilities.json
          output-format: json
          fail-build: false # We let OPA decide

      # --- Save artifacts for next jobs ---
      - name: Save Docker image to tarball
        run: docker save ${{ steps.vars.outputs.image }} -o /tmp/docker-image.tar

      - name: Upload Artifacts (SBOM & Scan)
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: |
            bom.json
            vulnerabilities.json
      
      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image.tar

  #========================================
  # JOB 2: ENFORCE (The Security Gate)
  #========================================
  policy-gate:
    name: 2 - Enforce Security Policy
    runs-on: ubuntu-latest
    needs: [build]

    steps:
      # --- FIX: ADD THIS STEP ---
      # We must check out the repo to get the policy/policy.rego file
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download security reports
        uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: .

      # --- FIX #3: Robust OPA Install ---
      - name: Install Open Policy Agent (OPA)
        run: |
          curl -L -o /tmp/opa https://github.com/open-policy-agent/opa/releases/latest/download/opa_linux_amd64
          chmod +x /tmp/opa
          sudo mv /tmp/opa /usr/local/bin/opa
          opa version

      - name: Create OPA Input JSON
        run: |
          jq -n --slurpfile grype vulnerabilities.json --slurpfile syft bom.json \
            '{"vulnerabilities": $grype[0], "sbom": $syft[0]}' > input.json
          echo "Generated input.json for OPA:"
          cat input.json | jq .

      # --- FIX #3: Robust OPA Evaluation ---
      - name: Run OPA Policy Gate
        id: opa_eval
        run: |
          # Run OPA and capture the JSON output
          # Use -d to load the specific policy *file*
          RESULT=$(opa eval -i input.json -d ./policy/policy.rego 'data.main.allow' --format=json)
          echo "OPA raw result: $RESULT"
          
          # Parse the JSON for a 'true' result
          PASSED=$(echo "$RESULT" | jq -r '.result[0].expressions[0].value // "false"')
          
          if [ "$PASSED" != "true" ]; then
            echo "OPA Policy FAILED!"
            # Optionally, show deny reasons if we configured them
            opa eval -i input.json -d ./policy/policy.rego 'data.main.deny'
            exit 1
          fi
          echo "OPA Policy PASSED"

  #========================================
  # JOB 3: ATTEST & PUBLISH
  #========================================
  sign-and-publish:
    name: 3 - Attest and Publish
    runs-on: ubuntu-latest
    needs: [build, policy-gate] # Depends on both
    permissions:
      contents: read
      packages: write
      id-token: write # Required for keyless signing

    steps:
      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      - uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: .

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Sigstore/cosign
        uses: sigstore/cosign-installer@v3

      # --- FIX #6: Robust Load/Tag/Push ---
      - name: Load, Tag, and Push image to registry
        run: |
          docker load -i /tmp/docker-image.tar
          # This re-tags the loaded image just in case the tag was lost, then pushes
          docker push ${{ needs.build.outputs.image_tag }}

      # --- FIX #2: Correct Cosign Keyless Signing ---
      - name: Sign the image with Cosign (keyless)
        env:
          COSIGN_EXPERIMENTAL: "1" # Still good practice
        run: |
          cosign sign --keyless ${{ needs.build.outputs.image_tag }}

      - name: Attach SBOM Attestation (keyless)
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          cosign attest --type cyclonedx --predicate ./bom.json --keyless ${{ needs.build.outputs.image_tag }}

      - name: Verify Image Signature (keyless)
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          # --keyless verification automatically checks the GitHub OIDC issuer
          # and identity against the repo. This is much cleaner.
          cosign verify --keyless ${{ needs.build.outputs.image_tag }}