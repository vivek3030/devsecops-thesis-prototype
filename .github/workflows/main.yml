# This is the main artifact of the thesis (Chapter 5)
# It implements the 4-stage framework: Build, Analyze, Enforce, Attest

name: DevSecOps Secure Supply Chain

on:
  push:
    branches: [ "main" ] # Triggers on push to main
  pull_request:
    branches: [ "main" ] # Triggers on PR to main
  workflow_dispatch:      # Allows manual triggering

# Global env variables
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  #========================================
  # JOB 1: BUILD & ANALYZE
  # (Builds the image, generates SBOM, scans for vulnerabilities)
  #========================================
  build:
    name: 1 - Build and Analyze
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      image_tag: ${{ steps.meta.outputs.tags }} # Use .tags instead of .version

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=,format=short

      # --- STAGE 1: BUILD ---
      - name: Build Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./app/Dockerfile # Verify this path
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # --- STAGE 2: ANALYZE (SBOM) ---
      - name: Generate SBOM (Syft)
        uses: anchore/sbom-action@v0
        with:
          target: image
          image: ${{ steps.meta.outputs.tags }}
          format: cyclonedx
          file: bom.json

      # --- STAGE 2: ANALYZE (Scan) ---
      - name: Scan for Vulnerabilities (Grype)
        uses: anchore/scan-action@v0
        with:
          sbom-file: bom.json
          output: vulnerabilities.json
          output-format: json
          skip-sbom-generation: true
          fail-build: false

      - name: Save Docker image to tarball
        run: docker save ${{ steps.meta.outputs.tags }} -o /tmp/docker-image.tar

      - name: Upload Artifacts (SBOM & Scan)
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: |
            bom.json
            vulnerabilities.json

      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image.tar

  #========================================
  # JOB 2: ENFORCE (The Security Gate)
  # (Uses OPA to check the reports)
  #========================================
  policy-gate:
    name: 2 - Enforce Security Policy
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      artifacts: read

    steps:
      - name: Checkout repository (for OPA policy file)
        uses: actions/checkout@v4

      - name: Download security reports
        uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: .

      - name: Install Open Policy Agent (OPA)
        run: |
          curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64
          chmod +x ./opa

      - name: Create OPA Input JSON
        run: |
          jq -n --slurpfile grype vulnerabilities.json --slurpfile syft bom.json \
            '{"vulnerabilities": $grype[0], "sbom": $syft[0]}' > input.json
          echo "Generated input.json for OPA:"
          cat input.json | jq .

      - name: Run OPA Policy Gate
        run: |
          ./opa eval --fail-defined \
            --input input.json \
            --data policy/policy.rego \
            --format json \
            "data.main.allow" > opa_result.json
          if [[ $(jq '.result[0].expressions[0].value' opa_result.json) == "true" ]]; then
            echo "OPA Policy PASSED"
          else
            echo "OPA Policy FAILED"
            exit 1
          fi

  #========================================
  # JOB 3: ATTEST & PUBLISH
  # (Signs the image with Sigstore and pushes)
  #========================================
  sign-and-publish:
    name: 3 - Attest and Publish
    runs-on: ubuntu-latest
    needs: [policy-gate]
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Download Docker Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load -i /tmp/docker-image.tar

      - name: Get Image Tag
        id: image_tag
        run: echo "tag=${{ needs.build.outputs.image_tag }}" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Sigstore/cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign the image with Sigstore
        run: |
          cosign sign \
            --yes \
            ${{ steps.image_tag.outputs.tag }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Download SBOM report
        uses: actions/download-artifact@v4
        with:
          name: security-reports
          path: .

      - name: Attach SBOM Attestation
        run: |
          cosign attest \
            --yes \
            --type spdx \
            --predicate bom.json \
            ${{ steps.image_tag.outputs.tag }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Verify Image Signature
        run: |
          cosign verify \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            ${{ steps.image_tag.outputs.tag }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Push signed image to registry
        run: |
          docker push ${{ steps.image_tag.outputs.tag }}
